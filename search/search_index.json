{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Liri Developers Documentation Introduction Liri uses Qt , a cross-platform framework, to build apps and libraries. The IDE of choice is QtCreator a cross-platform IDE dedicated to development with Qt. All projects use the popular CMake build system. Source code is managed with git and we use the git flow workflow. This means, in a nutshell, that the latest released code is in the master branch while development happens in the develop branch. Getting Started Liri requires a recent version of Qt therefore we recommend to develop on Arch Linux, because it is a great distro for developers and the software is always up to date. Some distributions like Ubuntu have very old Qt copies. If you cannot switch to Arch Linux, please consider installing the binaries provided by The Qt Company. Download the online installer and install both Qt and QtCreator. However keep in mind that the binaries provided by The Qt Company do not have QtWayland, this means that you will not be able to develop Liri Shell. Head over to the Contributor Guide for more information on how to set everything up. Getting in touch Connect with us on Twitter , Facebook , Reddit , Mastodon , Chat via Matrix.org or IRC to keep updated.","title":"Home"},{"location":"#liri-developers-documentation","text":"","title":"Liri Developers Documentation"},{"location":"#introduction","text":"Liri uses Qt , a cross-platform framework, to build apps and libraries. The IDE of choice is QtCreator a cross-platform IDE dedicated to development with Qt. All projects use the popular CMake build system. Source code is managed with git and we use the git flow workflow. This means, in a nutshell, that the latest released code is in the master branch while development happens in the develop branch.","title":"Introduction"},{"location":"#getting-started","text":"Liri requires a recent version of Qt therefore we recommend to develop on Arch Linux, because it is a great distro for developers and the software is always up to date. Some distributions like Ubuntu have very old Qt copies. If you cannot switch to Arch Linux, please consider installing the binaries provided by The Qt Company. Download the online installer and install both Qt and QtCreator. However keep in mind that the binaries provided by The Qt Company do not have QtWayland, this means that you will not be able to develop Liri Shell. Head over to the Contributor Guide for more information on how to set everything up.","title":"Getting Started"},{"location":"#getting-in-touch","text":"Connect with us on Twitter , Facebook , Reddit , Mastodon , Chat via Matrix.org or IRC to keep updated.","title":"Getting in touch"},{"location":"about/philosophy/","text":"The Liri environment Liri aims to offer an excellent desktop experience. Instead of forcing the user to know every detail of their computer, we expect them to turn it on, sit down and simply use it. We are able to achieve this through concise design methodology and the fact that all the applications built for Liri are designed from top to bottom to work together, offer consistency and stability, and deliver the features users want. To develop an excellent application, you will need to understand the environment and why our users love it. With this understanding, have no doubt that you will be able to establish an application that takes adventures of core platform features and an interface that integrates seamlessly into the desktop experience. A distraction free, content focused desktop Liri was created around the core belief that the majority of people use computers to create and experience digital content that they care about and throughout their daily activities. On a Liri device, the user is free to focus on their content and productivity because Liri performs many of the typical backend application management tasks that users are generally expected to handle. Avoiding manual configuration Liri is able to take much of the burden of adjusting and controlling the minor details of the system for the majority of users. This is achieved by promoting minimal configuration throughout the system and applications. Providing settings is usually an easy way out of making design decisions about an app\u2019s behavior. The same as feature bloat, increased user settings mean more code, more bugs, more testing, more documentation, and more overall complexity for the user. Creating An \"Out of the Box\" Experience Always design with sane defaults in focus. Liri applications put a strong emphasis on the out of the box experience for the users. It is safe to assume that if your app requires configuration before a user can be comfortable using it, the user may not take the time to configure it at all and simply use another app in place. Ask the OS, Not the User Get as much information automatically as possible. In place of asking the user for his or her name and location, ask the system for this information. This directly reduces the amount of tasks a user has to complete before they are able to have any amount of productivity, it also gives an extra layer of intelligence and integration to your app. Is It Necessary To The User Experience? Always contemplate on if the configuration option you are adding is really necessary or vital to the user. Avoid asking users to make engineering or design related decisions. Configuration options should be strictly regulated and assigned to either the initial setup of the app or personal preference. Contextual Display Keep things in context. Actively make design decisions that allow you to display preferences in context with the objects they affect, rather than tucked away in a configuration dialog. If your app requires configuration upon initial use, or before it can be used (like a mail client), present this configuration inside the main app window much like a Welcome Screen. Once again, be mindful to only present configuration options when necessary. Full-Screen Helps Users Focus At times it can make sense for an app to offer an immersive, full-screen experience to help users focus on tasks and avoid distractions from the desktop or background applications. Liri makes extensive use of this and compliments full-screen applications organically with ease. [INSERT FULL-SCREEN SCREENSHOT] Insert detailed information about the full-screen native functionality of applications. How Applications Display On Taskbar Relevant text. Customizing User Experience Via System Preferences Relevant text. User Help And Documentation Is Unobtrusively Available Relevant text. Multiple Users On A Single System Relevant text. Accessibility and Internationalization Relevant text. A Focus On Typography Relevant text.","title":"Philosophy"},{"location":"about/philosophy/#the-liri-environment","text":"Liri aims to offer an excellent desktop experience. Instead of forcing the user to know every detail of their computer, we expect them to turn it on, sit down and simply use it. We are able to achieve this through concise design methodology and the fact that all the applications built for Liri are designed from top to bottom to work together, offer consistency and stability, and deliver the features users want. To develop an excellent application, you will need to understand the environment and why our users love it. With this understanding, have no doubt that you will be able to establish an application that takes adventures of core platform features and an interface that integrates seamlessly into the desktop experience.","title":"The Liri environment"},{"location":"about/philosophy/#a-distraction-free-content-focused-desktop","text":"Liri was created around the core belief that the majority of people use computers to create and experience digital content that they care about and throughout their daily activities. On a Liri device, the user is free to focus on their content and productivity because Liri performs many of the typical backend application management tasks that users are generally expected to handle.","title":"A distraction free, content focused desktop"},{"location":"about/philosophy/#avoiding-manual-configuration","text":"Liri is able to take much of the burden of adjusting and controlling the minor details of the system for the majority of users. This is achieved by promoting minimal configuration throughout the system and applications. Providing settings is usually an easy way out of making design decisions about an app\u2019s behavior. The same as feature bloat, increased user settings mean more code, more bugs, more testing, more documentation, and more overall complexity for the user.","title":"Avoiding manual configuration"},{"location":"about/philosophy/#creating-an-out-of-the-box-experience","text":"Always design with sane defaults in focus. Liri applications put a strong emphasis on the out of the box experience for the users. It is safe to assume that if your app requires configuration before a user can be comfortable using it, the user may not take the time to configure it at all and simply use another app in place.","title":"Creating An \"Out of the Box\" Experience"},{"location":"about/philosophy/#ask-the-os-not-the-user","text":"Get as much information automatically as possible. In place of asking the user for his or her name and location, ask the system for this information. This directly reduces the amount of tasks a user has to complete before they are able to have any amount of productivity, it also gives an extra layer of intelligence and integration to your app.","title":"Ask the OS, Not the User"},{"location":"about/philosophy/#is-it-necessary-to-the-user-experience","text":"Always contemplate on if the configuration option you are adding is really necessary or vital to the user. Avoid asking users to make engineering or design related decisions. Configuration options should be strictly regulated and assigned to either the initial setup of the app or personal preference.","title":"Is It Necessary To The User Experience?"},{"location":"about/philosophy/#contextual-display","text":"Keep things in context. Actively make design decisions that allow you to display preferences in context with the objects they affect, rather than tucked away in a configuration dialog. If your app requires configuration upon initial use, or before it can be used (like a mail client), present this configuration inside the main app window much like a Welcome Screen. Once again, be mindful to only present configuration options when necessary.","title":"Contextual Display"},{"location":"about/philosophy/#full-screen-helps-users-focus","text":"At times it can make sense for an app to offer an immersive, full-screen experience to help users focus on tasks and avoid distractions from the desktop or background applications. Liri makes extensive use of this and compliments full-screen applications organically with ease. [INSERT FULL-SCREEN SCREENSHOT] Insert detailed information about the full-screen native functionality of applications.","title":"Full-Screen Helps Users Focus"},{"location":"about/philosophy/#how-applications-display-on-taskbar","text":"Relevant text.","title":"How Applications Display On Taskbar"},{"location":"about/philosophy/#customizing-user-experience-via-system-preferences","text":"Relevant text.","title":"Customizing User Experience Via System Preferences"},{"location":"about/philosophy/#user-help-and-documentation-is-unobtrusively-available","text":"Relevant text.","title":"User Help And Documentation Is Unobtrusively Available"},{"location":"about/philosophy/#multiple-users-on-a-single-system","text":"Relevant text.","title":"Multiple Users On A Single System"},{"location":"about/philosophy/#accessibility-and-internationalization","text":"Relevant text.","title":"Accessibility and Internationalization"},{"location":"about/philosophy/#a-focus-on-typography","text":"Relevant text.","title":"A Focus On Typography"},{"location":"about/project-management/","text":"Project management GitHub issues on each repository for detailed issue tracking GitHub issues on the lirios repository for general issue tracking and tasks ZenHub for enhanced issue tracking with Scrum/Kanban approach Slack for team communication Google Groups mailing list Google Docs for big picture collaborative docs Decisions and conflict resolution Need to find a healthy way to resolve conflicts if we disagree Adapt governance model to the Qt Governance Model Use a contribution agreement that would allow us to relicense under another Free Software License blessed by OSI or FSF without contacting tons of people (I want to avoid this https://github.com/papyros/qml-material/issues/361) We won\u2019t ask for copyright assignment and under no circumstances we\u2019ll be able to make the code proprietary. Versioning Use semantic versioning Liri OS MVP will start at version 0.9.0 since the shell and workspace code comes directly from Hawaii that reached 0.8.0 How do we version all the libraries, etc? Do we use the same version for each project and release everything at once?","title":"Project Management"},{"location":"about/project-management/#project-management","text":"GitHub issues on each repository for detailed issue tracking GitHub issues on the lirios repository for general issue tracking and tasks ZenHub for enhanced issue tracking with Scrum/Kanban approach Slack for team communication Google Groups mailing list Google Docs for big picture collaborative docs","title":"Project management"},{"location":"about/project-management/#decisions-and-conflict-resolution","text":"Need to find a healthy way to resolve conflicts if we disagree Adapt governance model to the Qt Governance Model Use a contribution agreement that would allow us to relicense under another Free Software License blessed by OSI or FSF without contacting tons of people (I want to avoid this https://github.com/papyros/qml-material/issues/361) We won\u2019t ask for copyright assignment and under no circumstances we\u2019ll be able to make the code proprietary.","title":"Decisions and conflict resolution"},{"location":"about/project-management/#versioning","text":"Use semantic versioning Liri OS MVP will start at version 0.9.0 since the shell and workspace code comes directly from Hawaii that reached 0.8.0 How do we version all the libraries, etc? Do we use the same version for each project and release everything at once?","title":"Versioning"},{"location":"contributing/build-sources/","text":"Introduction In this guide we deal with building the Liri projects from git. Check in the Contributor Guide how to get sources from the git repositories. Dependencies We need: Git (>= 1.6.x) A working C++ compiler Qt (>= 5.10) qtbase qtdoc qtdeclarative qtgraphicaleffects qtquickcontrols2 qtsvg qtwayland qttools qtmultimedia qtwebengine cmake (>= 3.10) Install dependencies Build essentials: Distro Command Debian sudo apt-get install -y build-essential git Arch Linux sudo pacman -Syu base-devel git Fedora sudo dnf install -y gcc-c++ git OpenSUSE sudo zypper install gcc-c++ git-core Qt and cmake: Distro Command Debian sudo apt-get install -y qt5-default qtquickcontrols2-5-dev qml-module-qtwayland-compositor qtwayland5-dev-tools qtwebengine5-dev-tools qtwebengine5-private-dev qtwebengine5-dev qtmultimedia5-dev qtsvg5 qt5-doc qttools5-dev cmake qtchooser Arch Linux sudo pacman -Syu qt5-quickcontrols2 qt5-wayland qt5-webengine qt5-multimedia qt5-svg qt5-doc qt5-tools cmake Fedora sudo dnf install -y qt5-qtbase-static qt5-qtbase-private-devel qt5-qtquickcontrols2-devel qt5-qtwayland-devel qt5-qtmultimedia-devel qt5-qtwebengine-devel qt5-qtsvg-devel qt5-qtdoc qt5-qttools-devel cmake qtchooser OpenSUSE sudo zypper install libqt5-qtquickcontrols2 libqt5-qtquickwayland-devel libqt5-qtwayland-private-headers-devel libqt5-qtwebengine-devel libqt5-qtmultimedia-devel libqt5-qtsvg-devel libqt5-qtdoc-devel libqt5-qttools-devel cmake Other dependencies: Distro Command Debian sudo apt-get install -y libwayland-dev wayland-protocols libpam0g-dev libpolkit-qt5-1-dev libpolkit-gobject-1-dev libkf5solid-dev libsystemd-dev libdrm-dev libgbm-dev libinput-dev libxcb-cursor-dev libxcursor-dev libpulse-dev libkf5networkmanagerqt-dev libmodemmanagerqt-dev libglib2.0-dev dconf-service dconf-cli dconf-gsettings-backend dconf-tools libpipewire-0.2-dev gstreamer1.0-pipewire libxkbcommon-dev libqtgstreamer-dev libflatpak-dev libappstreamqt-dev Arch Linux sudo pacman -Syu wayland pam polkit-qt5 solid libdrm libinput xcb-util-cursor pulseaudio networkmanager-qt modemmanager-qt glib2 dconf pipewire libxkbcommon flatpak appstream-qt Fedora sudo dnf install -y wayland-devel wayland-protocols-devel pam-devel polkit-devel polkit-qt5-1-devel kf5-solid-devel systemd-devel libdrm-devel mesa-libgbm-devel libinput-devel xcb-util-cursor-devel libXcursor-devel pulseaudio-libs-devel NetworkManager-libnm-devel ModemManager-glib-devel kf5-networkmanager-qt-devel kf5-modemmanager-qt-devel glib2-devel dconf pipewire-devel pipewire-utils libxkbcommon-devel flatpak-devel appstream-qt-devel OpenSUSE sudo zypper install wayland-devel wayland-protocols pam-devel polkit-devel libpolkit-qt5-1-devel solid-devel systemd-devel libdrm-devel libgbm-devel libinput-devel xcb-util-cursor-devel libXcursor-devel pulseaudio-libs-devel libKF5NetworkManagerQt-devel libKF5ModemManagerQt-devel glib-devel dconf gsettings-backend-dconf pipewire-devel pipewire-tools gstreamer-plugin-pipewire libxkbcommon-devel flatpak-devel libAppstreamQt-devel Marginal dependencies (used on unit tests, etc...): Distro Command Debian sudo apt-get install -y umockdev-dev Arch Linux sudo pacman -Syu umockdev Fedora sudo dnf install -y umockdev-devel OpenSUSE sudo zypper install umockdev-devel Build Developers should open CMakeLists.txt with QtCreator and build there, that is way easier. However if you know bash-fu it's possibile to build from sources. We assume you have a terminal open in the sources root directory, where there's CMakeLists.txt . Build: mkdir .build cd .build cmake -DCMAKE_INSTALL_PREFIX=$(pwd)/install-root .. make make install","title":"Build from Sources"},{"location":"contributing/build-sources/#introduction","text":"In this guide we deal with building the Liri projects from git. Check in the Contributor Guide how to get sources from the git repositories.","title":"Introduction"},{"location":"contributing/build-sources/#dependencies","text":"We need: Git (>= 1.6.x) A working C++ compiler Qt (>= 5.10) qtbase qtdoc qtdeclarative qtgraphicaleffects qtquickcontrols2 qtsvg qtwayland qttools qtmultimedia qtwebengine cmake (>= 3.10)","title":"Dependencies"},{"location":"contributing/build-sources/#install-dependencies","text":"Build essentials: Distro Command Debian sudo apt-get install -y build-essential git Arch Linux sudo pacman -Syu base-devel git Fedora sudo dnf install -y gcc-c++ git OpenSUSE sudo zypper install gcc-c++ git-core Qt and cmake: Distro Command Debian sudo apt-get install -y qt5-default qtquickcontrols2-5-dev qml-module-qtwayland-compositor qtwayland5-dev-tools qtwebengine5-dev-tools qtwebengine5-private-dev qtwebengine5-dev qtmultimedia5-dev qtsvg5 qt5-doc qttools5-dev cmake qtchooser Arch Linux sudo pacman -Syu qt5-quickcontrols2 qt5-wayland qt5-webengine qt5-multimedia qt5-svg qt5-doc qt5-tools cmake Fedora sudo dnf install -y qt5-qtbase-static qt5-qtbase-private-devel qt5-qtquickcontrols2-devel qt5-qtwayland-devel qt5-qtmultimedia-devel qt5-qtwebengine-devel qt5-qtsvg-devel qt5-qtdoc qt5-qttools-devel cmake qtchooser OpenSUSE sudo zypper install libqt5-qtquickcontrols2 libqt5-qtquickwayland-devel libqt5-qtwayland-private-headers-devel libqt5-qtwebengine-devel libqt5-qtmultimedia-devel libqt5-qtsvg-devel libqt5-qtdoc-devel libqt5-qttools-devel cmake Other dependencies: Distro Command Debian sudo apt-get install -y libwayland-dev wayland-protocols libpam0g-dev libpolkit-qt5-1-dev libpolkit-gobject-1-dev libkf5solid-dev libsystemd-dev libdrm-dev libgbm-dev libinput-dev libxcb-cursor-dev libxcursor-dev libpulse-dev libkf5networkmanagerqt-dev libmodemmanagerqt-dev libglib2.0-dev dconf-service dconf-cli dconf-gsettings-backend dconf-tools libpipewire-0.2-dev gstreamer1.0-pipewire libxkbcommon-dev libqtgstreamer-dev libflatpak-dev libappstreamqt-dev Arch Linux sudo pacman -Syu wayland pam polkit-qt5 solid libdrm libinput xcb-util-cursor pulseaudio networkmanager-qt modemmanager-qt glib2 dconf pipewire libxkbcommon flatpak appstream-qt Fedora sudo dnf install -y wayland-devel wayland-protocols-devel pam-devel polkit-devel polkit-qt5-1-devel kf5-solid-devel systemd-devel libdrm-devel mesa-libgbm-devel libinput-devel xcb-util-cursor-devel libXcursor-devel pulseaudio-libs-devel NetworkManager-libnm-devel ModemManager-glib-devel kf5-networkmanager-qt-devel kf5-modemmanager-qt-devel glib2-devel dconf pipewire-devel pipewire-utils libxkbcommon-devel flatpak-devel appstream-qt-devel OpenSUSE sudo zypper install wayland-devel wayland-protocols pam-devel polkit-devel libpolkit-qt5-1-devel solid-devel systemd-devel libdrm-devel libgbm-devel libinput-devel xcb-util-cursor-devel libXcursor-devel pulseaudio-libs-devel libKF5NetworkManagerQt-devel libKF5ModemManagerQt-devel glib-devel dconf gsettings-backend-dconf pipewire-devel pipewire-tools gstreamer-plugin-pipewire libxkbcommon-devel flatpak-devel libAppstreamQt-devel Marginal dependencies (used on unit tests, etc...): Distro Command Debian sudo apt-get install -y umockdev-dev Arch Linux sudo pacman -Syu umockdev Fedora sudo dnf install -y umockdev-devel OpenSUSE sudo zypper install umockdev-devel","title":"Install dependencies"},{"location":"contributing/build-sources/#build","text":"Developers should open CMakeLists.txt with QtCreator and build there, that is way easier. However if you know bash-fu it's possibile to build from sources. We assume you have a terminal open in the sources root directory, where there's CMakeLists.txt . Build: mkdir .build cd .build cmake -DCMAKE_INSTALL_PREFIX=$(pwd)/install-root .. make make install","title":"Build"},{"location":"contributing/upstream-issues/","text":"Upstream Issues This is a living document that lists issues from upstream projects that introduce problems to Liri OS and apps and whose resolution is not a Liri responsability. Wayland Wayland needs to address some issues before claiming feature parity with Xorg. A client cannot change the keymap. This would be required to let Calamares change the keyboard layout, otherwise the user won't be able to test the keyboard layout during the installation. A compositor cannot change the cursor theme on all clients. We can craft a solution only for Qt clients, but it won't work for other toolkits. This means that changing the cursor theme from Settings requires to restart the desktop. XWayland Clients are blurry on HiDPI. See this IRC conversation: <plfiorini> xwayland clients seem blurry on hidpi, compared to their wayland counterpart. doesn't seem to be a toolkit issue since this happens with both gtk and qt. is this a known issue? <SardemFF7> plfiorini: short answer: yes, nothing can be done about it <plfiorini> SardemFF7, so nothing i could fix with the compositor author hat on? <SardemFF7> the long answer is that you could, maybe, fix some of the clients by providing more information, or by lying, but that may break other clients, so you\u2019d probably need special extra support in X11 toolkits/apps to make it work, and they probably have Wayland support anyway <fredrikh> a different scaling filter could help <SardemFF7> that one is up to the compositor <SardemFF7> but I don\u2019t think it\u2019d fix everything magically <fredrikh> nope <fredrikh> still, bilnear is probably the worst magnification filter if you don't want to things to look blurry <plfiorini> thanks for your answer <SardemFF7> plfiorini: there is a thread on the ML about that, btw <SardemFF7> plfiorini: https://lists.freedesktop.org/archives/wayland-devel/2017-September/034957.html QtDeclarative TextEdit doesn't correctly update formats set by QSyntaxHighlighter: QTBUG-58092 ListView with transitions does not always position delegates properly: QTBUG-62148 QtWayland Qt 5.8.0 introduces QtWayland as an official module, finally the QtWaylandCompositor framework is considered stable. However it still lack a few features or has bugs that need to be fixed: Partial subsurface support: missing raise, lower and synchronization. D&D works only on one output: QTBUG-55584 No support for animated mouse cursors: QTBUG-48181 Dropdown window closes on key press: QTBUG-55403 Compose key support missing in QtWayland: QTBUG-54792 FIXED IN 5.11.0 Key repeat settings ignored: QTBUG-55615 [Wayland] Modifiers not working in wheelEvent: QTBUG-61488 QtQuick Controls 2 Roboto doesn't support all languages, should fallback to Noto: QTBUG-59579 Dialog should respond to Enter key: QTBUG-60361 MenuItem is not triggered by the \"Enter\" key: QTBUG-67275 QtWebEngine Crashes on Wayland, means that Liri Browser doesn't work on Wayland: QTBUG-55384 Solid udisks2 backend makes blocking dbus calls: 380990 Gtk+ While Liri OS is focused on Qt applications, we still want compatibility with Gtk+ applications. Bad app_id for Gtk+ apps: 769641 Snap Online Services build.snapcraft.io doesn't respect publishing rights for shared snaps: #799 Proxy token lifetime for launchpad-buildd is limited 1709678 Snapcraft qmake plugin doesn't support choosing a custom Qt version: 1670146","title":"Upstream Issues"},{"location":"contributing/upstream-issues/#upstream-issues","text":"This is a living document that lists issues from upstream projects that introduce problems to Liri OS and apps and whose resolution is not a Liri responsability.","title":"Upstream Issues"},{"location":"contributing/upstream-issues/#wayland","text":"Wayland needs to address some issues before claiming feature parity with Xorg. A client cannot change the keymap. This would be required to let Calamares change the keyboard layout, otherwise the user won't be able to test the keyboard layout during the installation. A compositor cannot change the cursor theme on all clients. We can craft a solution only for Qt clients, but it won't work for other toolkits. This means that changing the cursor theme from Settings requires to restart the desktop.","title":"Wayland"},{"location":"contributing/upstream-issues/#xwayland","text":"Clients are blurry on HiDPI. See this IRC conversation: <plfiorini> xwayland clients seem blurry on hidpi, compared to their wayland counterpart. doesn't seem to be a toolkit issue since this happens with both gtk and qt. is this a known issue? <SardemFF7> plfiorini: short answer: yes, nothing can be done about it <plfiorini> SardemFF7, so nothing i could fix with the compositor author hat on? <SardemFF7> the long answer is that you could, maybe, fix some of the clients by providing more information, or by lying, but that may break other clients, so you\u2019d probably need special extra support in X11 toolkits/apps to make it work, and they probably have Wayland support anyway <fredrikh> a different scaling filter could help <SardemFF7> that one is up to the compositor <SardemFF7> but I don\u2019t think it\u2019d fix everything magically <fredrikh> nope <fredrikh> still, bilnear is probably the worst magnification filter if you don't want to things to look blurry <plfiorini> thanks for your answer <SardemFF7> plfiorini: there is a thread on the ML about that, btw <SardemFF7> plfiorini: https://lists.freedesktop.org/archives/wayland-devel/2017-September/034957.html","title":"XWayland"},{"location":"contributing/upstream-issues/#qtdeclarative","text":"TextEdit doesn't correctly update formats set by QSyntaxHighlighter: QTBUG-58092 ListView with transitions does not always position delegates properly: QTBUG-62148","title":"QtDeclarative"},{"location":"contributing/upstream-issues/#qtwayland","text":"Qt 5.8.0 introduces QtWayland as an official module, finally the QtWaylandCompositor framework is considered stable. However it still lack a few features or has bugs that need to be fixed: Partial subsurface support: missing raise, lower and synchronization. D&D works only on one output: QTBUG-55584 No support for animated mouse cursors: QTBUG-48181 Dropdown window closes on key press: QTBUG-55403 Compose key support missing in QtWayland: QTBUG-54792 FIXED IN 5.11.0 Key repeat settings ignored: QTBUG-55615 [Wayland] Modifiers not working in wheelEvent: QTBUG-61488","title":"QtWayland"},{"location":"contributing/upstream-issues/#qtquick-controls-2","text":"Roboto doesn't support all languages, should fallback to Noto: QTBUG-59579 Dialog should respond to Enter key: QTBUG-60361 MenuItem is not triggered by the \"Enter\" key: QTBUG-67275","title":"QtQuick Controls 2"},{"location":"contributing/upstream-issues/#qtwebengine","text":"Crashes on Wayland, means that Liri Browser doesn't work on Wayland: QTBUG-55384","title":"QtWebEngine"},{"location":"contributing/upstream-issues/#solid","text":"udisks2 backend makes blocking dbus calls: 380990","title":"Solid"},{"location":"contributing/upstream-issues/#gtk","text":"While Liri OS is focused on Qt applications, we still want compatibility with Gtk+ applications. Bad app_id for Gtk+ apps: 769641","title":"Gtk+"},{"location":"contributing/upstream-issues/#snap-online-services","text":"build.snapcraft.io doesn't respect publishing rights for shared snaps: #799 Proxy token lifetime for launchpad-buildd is limited 1709678","title":"Snap Online Services"},{"location":"contributing/upstream-issues/#snapcraft","text":"qmake plugin doesn't support choosing a custom Qt version: 1670146","title":"Snapcraft"},{"location":"contributing/coding-conventions/cpp-conventions/","text":"C++ Coding Conventions This is an overview of the high-level coding conventions we use when writing Qt code. See C++ Coding Style for the lower-level conventions. For QML, see QML Coding Conventions . C++ features Don't use exceptions Don't use rtti (Run-Time Type Information; that is, the typeinfo struct, the dynamic_cast or the typeid operators, including throwing exceptions) Use templates wisely, not just because you can. Conventions in C++ source code All code is ascii only (7-bit characters only, run man ascii if unsure) Rationale: We have too many locales inhouse and an unhealthy mix of UTF-8 and latin1 systems. Usually, characters > 127 can be broken without you even knowing by clicking SAVE in your favourite editor. For strings: Use \\nnn (where nnn is the octal representation of whatever character encoding you want your string in) or \\xnn (where nn is hexadecimal). Example: QString s = QString::fromUtf8(\"13\\005\"); For umlauts in documentation, or other non-ASCII characters, either use qdoc's command or use the relevant macro; e.g. \\uuml for \u00fc. Every QObject subclass must have a Q_OBJECT macro, even if it doesn't have signals or slots, otherwise qobject_cast will fail. Normalize the arguments for signals + slots (see QMetaObject::normalizedSignature ) inside connect statements to get faster signal/slot lookups. You can use qtrepotools/util/normalize to normalize existing code. Including headers In public header files, always use this form to include Qt headers: #include <QtCore/qwhatever.h> . The library prefix is necessary for Mac OS X frameworks and is very convenient for non-qmake projects. In source files, include specialized headers first, then generic headers. Separate the categories with empty lines. #include <qstring.h> // Qt class #include <new> // STL stuff #include <limits.h> // system stuff If you need to include qplatformdefs.h , always include it as the '''first''' header file. If you need to include private headers, be careful. Use the following syntax, irrespective of which module or directory whatever_p.h is in. #include <private/whatever_p.h> Include guards Never use #pragma once because it's not part of the C++ standard, it's not always supported and it's subject to double inclusion if any headers are copied somehere in the build process (which we does). Use include guards instead like these: #ifndef SOMEFILENAME_H #define SOMEFILENAME_H // contents #endif // SOMEFILENAME_H See the following threads from the Qt mailing list: https://lists.qt-project.org/pipermail/development/2018-January/031966.html https://lists.qt-project.org/pipermail/development/2018-October/033726.html Casting Avoid C casts, prefer C++ casts ( static_cast , const_cast , reinterpret_cast ) Rationale: Both reinterpret_cast and C-style casts are dangerous, but at least reinterpret_cast won't remove the const modifier Don't use dynamic_cast , use qobject_cast for QObjects or refactor your design, for example by introducing a type() method (see QListWidgetItem) Use the constructor to cast simple types: int(myFloat) instead of (int)myFloat Rationale: When refactoring code, the compiler will instantly let you know if the cast would become dangerous. Compiler/Platform specific issues Be extremely careful when using the questionmark operator. If the returned types aren't identical, some compilers generate code that crashes at runtime (you won't even get a compiler warning). QString s; return condition ? s : \"nothing\"; // crash at runtime - QString vs. const char * Be extremely careful about alignment. Whenever a pointer is cast such that the required alignment of the target is increased, the resulting code might crash at runtime on some architectures. For example, if a const char * is cast to an const int * , it'll crash on machines where integers have to be aligned at two- or four-byte boundaries. Use a union to force the compiler to align variables correctly. In the example below, you can be sure that all instances of AlignHelper are aligned at integer-boundaries. union AlignHelper { char c; int i; }; Anything that has a constructor or needs to run code to be initialized cannot be used as global object in library code, since it is undefined when that constructor/code will be run (on first usage, on library load, before main() or not at all). Even if the execution time of the initializer is defined for shared libraries, you'll get into trouble when moving that code in a plugin or if the library is compiled statically: // global scope static const QString x; // Wrong - default constructor needs to be run to initialize x static const QString y = \"Hello\"; // Wrong - constructor that takes a const char * has to be run QString z; // super wrong static const int i = foo(); // wrong - call time of foo() undefined, might not be called at all Things you can do: // global scope static const char x[] = \"someText\"; // Works - no constructor must be run, x set at compile time static int y = 7; // Works - y will be set at compile time static MyStruct s = {1, 2, 3}; // Works - will be initialized statically, no code being run static QString *ptr = 0; // Pointers to objects are ok - no code needed to be run to initialize ptr Use Q_GLOBAL_STATIC to create static global objects instead: Q_GLOBAL_STATIC(QString, s) void foo() { s()->append(\"moo\"); } Note: Static objects in a scope are no problem, the constructor will be run the first time the scope is entered. The code is not reentrant, though. A char is signed or unsigned dependent on the architecture. Use signed char or unsigned char if you explicitely want a signed/unsigned char. The condition in the following code is always true on platforms where the default char is unsigned. char c; // c can't be negative if it is unsigned if (c > 0) { \u2026 } // WRONG - condition is always true on platforms where the default is unsigned Avoid 64-bit enum values. The aapcs embedded ABI hard codes all enum values to a 32-bit integer. Microsoft compilers don't support 64-bit enum values. (confirmed with Microsoft \u00ae C/C++ Optimizing Compiler Version 15.00.30729.01 for x64) Aesthetics Prefer enums to define constants over static const int or defines. enum values will be replaced by the compiler at compile time, resulting in faster code defines are not namespace safe (and look ugly) Prefer verbose argument names in headers. Most IDEs will show the argument names in their completion-box. It will look better in the documentation Bad style: doSomething(QRegion rgn, QPoint p) - use doSomething(QRegion clientRegion, QPoint gravitySource) instead When reimplementing a virtual method, do not put the virtual keyword in the header file. On Qt5, annotate them with the Q_DECL_OVERRIDE macro after the function declaration, just before the ; (or the { ). Things to avoid Do not inherit from template/tool classes The destructors are not virtual, leading to potential memory leaks The symbols are not exported (and mostly inline), leading to interesting symbol clashes. Example: Library A has class Q_EXPORT X: public QList<QVariant> {}; and library B has class Q_EXPORT Y: public QList<QVariant> {}; Suddenly, QList 's symbols are exported from two libraries - /clash/. Don't mix const and non-const iterators. This will silently crash on broken compilers. for (Container::const_iterator it = c.begin(); it != c.end(); ++it) // W R O N G for (Container::const_iterator it = c.cbegin(); it != c.cend(); ++it) // Right Q[Core]Application is a singleton class. There can only be one instance at a time. However, that instance can be destroyed and a new one can be created, which is likely in an ActiveQt or browser plugin. Code like this will easily break: static QObject *obj = 0; if (!obj) obj = new QObject(QCoreApplication::instance()); If the QCoreApplication application is destroyed, obj will be a dangling pointer. Use Q_GLOBAL_STATIC for static global objects or qAddPostRoutine to clean up. Avoid the use of anonymous namespaces in favor of the static keyword if possible. A name localized to the compilation unit with static is guaranteed to have internal linkage. For names declared in anonymous namespaces the C++ standard unfortunately mandates external linkage. (7.1.1/6, or see various discussions about this on the gcc mailing lists) Binary and Source Compatibility Definitions: Qt 4.0.0 is a major release, Qt 4.1.0 is a minor release, Qt 4.1.1 is a patch release Backward binary compatibility: Code linked to an earlier version of the library keeps working Forward binary compatibility: Code linked to a newer version of the library works with an older library Source code compatibility: Code compiles without modification Keep backward binary compatibility + backward source code compatibility in minor releases Keep backward and forward binary compatibility + forward and backward source code compatibility in patch releases Don't add/remove any public API (e.g. global functions, public/protected/private methods) Don't reimplement methods (not even inlines, nor protected/private methods) Check [[Binary Compatibility Workarounds]] for ways to keep b/c Info on binary compatibility: https://community.kde.org/Policies/Binary_Compatibility_Issues_With_C++ When writing a QWidget subclass, always reimplement event(), even if it's empty. This makes sure that the widget can be fixed without breaking binary compatibility. All exported functions from Qt must start with either 'q' or 'Q'. Use the \"symbols\" autotest to find violations. Operators \"The decision between member and non-member\" A binary operator that treats both of its arguments equally should not be a member. Because, in addition to the reasons mentioned in the stack overflow answer, the arguments are not equal when the operator is a member. Example with QLineF which unfortunately has its operator== as a member: QLineF lineF; QLine lineN; if (lineF == lineN) // Ok, lineN is implicitly converted to QLineF if (lineN == lineF) // Error: QLineF cannot be converted implicitly to QLine, and the LHS is a member so no conversion applies If the operator== was outside of the class, conversion rules would apply equally for both sides. Conventions for public header files Our public header files have to survive the strict settings of some of our users. All installed headers have to follow these rules: No C style casts ( -Wold-style-cast ) Use static_cast, const_cast or reinterpret_cast for basic types, use the constructor form: int(a) instead of (int)a See chapter \"Casting\" for more info No float comparisons ( -Wfloat-equal ) Use qFuzzyCompare to compare values with a delta Use qIsNull to check whether a float is binary 0, instead of comparing it to 0.0. Don't hide virtual methods in subclasses ( -Woverloaded-virtual ) If the baseclass A has a virtual int val() and subclass B an overload with the same name, int val(int x) , A 's val function is hidden. Use the using keyword to make it visible again: class B: public A { using A::val; int val(int x); }; Don't shadow variables ( -Wshadow ) avoid things like this->x = x; don't give variables the same name as functions declared in your class Always check whether a preprocessor variable is defined before probing its value ( -Wundef ) #if Foo == 0 // W R O N G #if defined(Foo) && (Foo == 0) // Right #if Foo - 0 == 0 // Clever, are we? Use the one above instead, for better readability Conventions for C++11 usage Note: This section is not an accepted convention yet. This section serves as baseline for further discussions. Lambdas You can use lambdas with the following restrictions: You have to explicitly specify the return type, if the lambda contains more than a single expression. Otherwise it does not compile with VS2010. []() -> QString { Foo *foo = activeFoo(); return foo ? foo->displayName() : QString(); }); NOT []() { Foo *foo = activeFoo(); return foo ? foo->displayName() : QString(); }); If you use static functions from the class that the lambda is located in, you have to explicitly capture this. Otherwise it does not compile with g++ 4.7 and earlier. void Foo::something() { ... [this]() { Foo::someStaticFunction(); } ... } NOT void Foo::something() { ... []() { Foo::someStaticFunction(); } ... } Format the lambda according to the following rules: Always write parentheses for the parameter list, even if the function does not take parameters. []() { doSomething(); } NOT [] { doSomething(); } Place the capture-list, parameter list, return type, and opening brace on the first line, the body indented on the following lines, and the closing brace on a new line. []() -> bool { something(); return isSomethingElse(); } NOT []() -> bool { something(); somethingElse(); } Place a closing parenthesis and semicolon of an enclosing function call on the same line as the closing brace of the lambda. foo([]() { something(); }); If you are using a lambda in an 'if' statement, start the lambda on a new line, to avoid confusion between the opening brace for the lambda and the opening brace for the 'if' statement. if (anyOf(fooList, [](Foo foo) { return foo.isGreat(); }) { return; } NOT if (anyOf(fooList, [](Foo foo) { return foo.isGreat(); }) { return; } Optionally, place the lambda completely on one line if it fits. foo([]() { return true; }); if (foo([]() { return true; })) { ... } auto Keyword Optionally, you can use the auto keyword in the following cases. If in doubt, for example if using auto could make the code less readable, do not use auto. Keep in mind that code is read much more often than written. When it avoids repetition of a type in the same statement. auto something = new MyCustomType; auto keyEvent = static_cast<QKeyEvent *>(event); auto myList = QStringList() << QLatin1String(\"FooThing\") << QLatin1String(\"BarThing\"); When assigning iterator types. auto it = myList.const_iterator();","title":"C++ Coding Conventions"},{"location":"contributing/coding-conventions/cpp-conventions/#c-coding-conventions","text":"This is an overview of the high-level coding conventions we use when writing Qt code. See C++ Coding Style for the lower-level conventions. For QML, see QML Coding Conventions .","title":"C++ Coding Conventions"},{"location":"contributing/coding-conventions/cpp-conventions/#c-features","text":"Don't use exceptions Don't use rtti (Run-Time Type Information; that is, the typeinfo struct, the dynamic_cast or the typeid operators, including throwing exceptions) Use templates wisely, not just because you can.","title":"C++ features"},{"location":"contributing/coding-conventions/cpp-conventions/#conventions-in-c-source-code","text":"All code is ascii only (7-bit characters only, run man ascii if unsure) Rationale: We have too many locales inhouse and an unhealthy mix of UTF-8 and latin1 systems. Usually, characters > 127 can be broken without you even knowing by clicking SAVE in your favourite editor. For strings: Use \\nnn (where nnn is the octal representation of whatever character encoding you want your string in) or \\xnn (where nn is hexadecimal). Example: QString s = QString::fromUtf8(\"13\\005\"); For umlauts in documentation, or other non-ASCII characters, either use qdoc's command or use the relevant macro; e.g. \\uuml for \u00fc. Every QObject subclass must have a Q_OBJECT macro, even if it doesn't have signals or slots, otherwise qobject_cast will fail. Normalize the arguments for signals + slots (see QMetaObject::normalizedSignature ) inside connect statements to get faster signal/slot lookups. You can use qtrepotools/util/normalize to normalize existing code.","title":"Conventions in C++ source code"},{"location":"contributing/coding-conventions/cpp-conventions/#including-headers","text":"In public header files, always use this form to include Qt headers: #include <QtCore/qwhatever.h> . The library prefix is necessary for Mac OS X frameworks and is very convenient for non-qmake projects. In source files, include specialized headers first, then generic headers. Separate the categories with empty lines. #include <qstring.h> // Qt class #include <new> // STL stuff #include <limits.h> // system stuff If you need to include qplatformdefs.h , always include it as the '''first''' header file. If you need to include private headers, be careful. Use the following syntax, irrespective of which module or directory whatever_p.h is in. #include <private/whatever_p.h>","title":"Including headers"},{"location":"contributing/coding-conventions/cpp-conventions/#include-guards","text":"Never use #pragma once because it's not part of the C++ standard, it's not always supported and it's subject to double inclusion if any headers are copied somehere in the build process (which we does). Use include guards instead like these: #ifndef SOMEFILENAME_H #define SOMEFILENAME_H // contents #endif // SOMEFILENAME_H See the following threads from the Qt mailing list: https://lists.qt-project.org/pipermail/development/2018-January/031966.html https://lists.qt-project.org/pipermail/development/2018-October/033726.html","title":"Include guards"},{"location":"contributing/coding-conventions/cpp-conventions/#casting","text":"Avoid C casts, prefer C++ casts ( static_cast , const_cast , reinterpret_cast ) Rationale: Both reinterpret_cast and C-style casts are dangerous, but at least reinterpret_cast won't remove the const modifier Don't use dynamic_cast , use qobject_cast for QObjects or refactor your design, for example by introducing a type() method (see QListWidgetItem) Use the constructor to cast simple types: int(myFloat) instead of (int)myFloat Rationale: When refactoring code, the compiler will instantly let you know if the cast would become dangerous.","title":"Casting"},{"location":"contributing/coding-conventions/cpp-conventions/#compilerplatform-specific-issues","text":"Be extremely careful when using the questionmark operator. If the returned types aren't identical, some compilers generate code that crashes at runtime (you won't even get a compiler warning). QString s; return condition ? s : \"nothing\"; // crash at runtime - QString vs. const char * Be extremely careful about alignment. Whenever a pointer is cast such that the required alignment of the target is increased, the resulting code might crash at runtime on some architectures. For example, if a const char * is cast to an const int * , it'll crash on machines where integers have to be aligned at two- or four-byte boundaries. Use a union to force the compiler to align variables correctly. In the example below, you can be sure that all instances of AlignHelper are aligned at integer-boundaries. union AlignHelper { char c; int i; }; Anything that has a constructor or needs to run code to be initialized cannot be used as global object in library code, since it is undefined when that constructor/code will be run (on first usage, on library load, before main() or not at all). Even if the execution time of the initializer is defined for shared libraries, you'll get into trouble when moving that code in a plugin or if the library is compiled statically: // global scope static const QString x; // Wrong - default constructor needs to be run to initialize x static const QString y = \"Hello\"; // Wrong - constructor that takes a const char * has to be run QString z; // super wrong static const int i = foo(); // wrong - call time of foo() undefined, might not be called at all Things you can do: // global scope static const char x[] = \"someText\"; // Works - no constructor must be run, x set at compile time static int y = 7; // Works - y will be set at compile time static MyStruct s = {1, 2, 3}; // Works - will be initialized statically, no code being run static QString *ptr = 0; // Pointers to objects are ok - no code needed to be run to initialize ptr Use Q_GLOBAL_STATIC to create static global objects instead: Q_GLOBAL_STATIC(QString, s) void foo() { s()->append(\"moo\"); } Note: Static objects in a scope are no problem, the constructor will be run the first time the scope is entered. The code is not reentrant, though. A char is signed or unsigned dependent on the architecture. Use signed char or unsigned char if you explicitely want a signed/unsigned char. The condition in the following code is always true on platforms where the default char is unsigned. char c; // c can't be negative if it is unsigned if (c > 0) { \u2026 } // WRONG - condition is always true on platforms where the default is unsigned Avoid 64-bit enum values. The aapcs embedded ABI hard codes all enum values to a 32-bit integer. Microsoft compilers don't support 64-bit enum values. (confirmed with Microsoft \u00ae C/C++ Optimizing Compiler Version 15.00.30729.01 for x64)","title":"Compiler/Platform specific issues"},{"location":"contributing/coding-conventions/cpp-conventions/#aesthetics","text":"Prefer enums to define constants over static const int or defines. enum values will be replaced by the compiler at compile time, resulting in faster code defines are not namespace safe (and look ugly) Prefer verbose argument names in headers. Most IDEs will show the argument names in their completion-box. It will look better in the documentation Bad style: doSomething(QRegion rgn, QPoint p) - use doSomething(QRegion clientRegion, QPoint gravitySource) instead When reimplementing a virtual method, do not put the virtual keyword in the header file. On Qt5, annotate them with the Q_DECL_OVERRIDE macro after the function declaration, just before the ; (or the { ).","title":"Aesthetics"},{"location":"contributing/coding-conventions/cpp-conventions/#things-to-avoid","text":"Do not inherit from template/tool classes The destructors are not virtual, leading to potential memory leaks The symbols are not exported (and mostly inline), leading to interesting symbol clashes. Example: Library A has class Q_EXPORT X: public QList<QVariant> {}; and library B has class Q_EXPORT Y: public QList<QVariant> {}; Suddenly, QList 's symbols are exported from two libraries - /clash/. Don't mix const and non-const iterators. This will silently crash on broken compilers. for (Container::const_iterator it = c.begin(); it != c.end(); ++it) // W R O N G for (Container::const_iterator it = c.cbegin(); it != c.cend(); ++it) // Right Q[Core]Application is a singleton class. There can only be one instance at a time. However, that instance can be destroyed and a new one can be created, which is likely in an ActiveQt or browser plugin. Code like this will easily break: static QObject *obj = 0; if (!obj) obj = new QObject(QCoreApplication::instance()); If the QCoreApplication application is destroyed, obj will be a dangling pointer. Use Q_GLOBAL_STATIC for static global objects or qAddPostRoutine to clean up. Avoid the use of anonymous namespaces in favor of the static keyword if possible. A name localized to the compilation unit with static is guaranteed to have internal linkage. For names declared in anonymous namespaces the C++ standard unfortunately mandates external linkage. (7.1.1/6, or see various discussions about this on the gcc mailing lists)","title":"Things to avoid"},{"location":"contributing/coding-conventions/cpp-conventions/#binary-and-source-compatibility","text":"Definitions: Qt 4.0.0 is a major release, Qt 4.1.0 is a minor release, Qt 4.1.1 is a patch release Backward binary compatibility: Code linked to an earlier version of the library keeps working Forward binary compatibility: Code linked to a newer version of the library works with an older library Source code compatibility: Code compiles without modification Keep backward binary compatibility + backward source code compatibility in minor releases Keep backward and forward binary compatibility + forward and backward source code compatibility in patch releases Don't add/remove any public API (e.g. global functions, public/protected/private methods) Don't reimplement methods (not even inlines, nor protected/private methods) Check [[Binary Compatibility Workarounds]] for ways to keep b/c Info on binary compatibility: https://community.kde.org/Policies/Binary_Compatibility_Issues_With_C++ When writing a QWidget subclass, always reimplement event(), even if it's empty. This makes sure that the widget can be fixed without breaking binary compatibility. All exported functions from Qt must start with either 'q' or 'Q'. Use the \"symbols\" autotest to find violations.","title":"Binary and Source Compatibility"},{"location":"contributing/coding-conventions/cpp-conventions/#operators","text":"\"The decision between member and non-member\" A binary operator that treats both of its arguments equally should not be a member. Because, in addition to the reasons mentioned in the stack overflow answer, the arguments are not equal when the operator is a member. Example with QLineF which unfortunately has its operator== as a member: QLineF lineF; QLine lineN; if (lineF == lineN) // Ok, lineN is implicitly converted to QLineF if (lineN == lineF) // Error: QLineF cannot be converted implicitly to QLine, and the LHS is a member so no conversion applies If the operator== was outside of the class, conversion rules would apply equally for both sides.","title":"Operators"},{"location":"contributing/coding-conventions/cpp-conventions/#conventions-for-public-header-files","text":"Our public header files have to survive the strict settings of some of our users. All installed headers have to follow these rules: No C style casts ( -Wold-style-cast ) Use static_cast, const_cast or reinterpret_cast for basic types, use the constructor form: int(a) instead of (int)a See chapter \"Casting\" for more info No float comparisons ( -Wfloat-equal ) Use qFuzzyCompare to compare values with a delta Use qIsNull to check whether a float is binary 0, instead of comparing it to 0.0. Don't hide virtual methods in subclasses ( -Woverloaded-virtual ) If the baseclass A has a virtual int val() and subclass B an overload with the same name, int val(int x) , A 's val function is hidden. Use the using keyword to make it visible again: class B: public A { using A::val; int val(int x); }; Don't shadow variables ( -Wshadow ) avoid things like this->x = x; don't give variables the same name as functions declared in your class Always check whether a preprocessor variable is defined before probing its value ( -Wundef ) #if Foo == 0 // W R O N G #if defined(Foo) && (Foo == 0) // Right #if Foo - 0 == 0 // Clever, are we? Use the one above instead, for better readability","title":"Conventions for public header files"},{"location":"contributing/coding-conventions/cpp-conventions/#conventions-for-c11-usage","text":"Note: This section is not an accepted convention yet. This section serves as baseline for further discussions.","title":"Conventions for C++11 usage"},{"location":"contributing/coding-conventions/cpp-conventions/#lambdas","text":"You can use lambdas with the following restrictions: You have to explicitly specify the return type, if the lambda contains more than a single expression. Otherwise it does not compile with VS2010. []() -> QString { Foo *foo = activeFoo(); return foo ? foo->displayName() : QString(); }); NOT []() { Foo *foo = activeFoo(); return foo ? foo->displayName() : QString(); }); If you use static functions from the class that the lambda is located in, you have to explicitly capture this. Otherwise it does not compile with g++ 4.7 and earlier. void Foo::something() { ... [this]() { Foo::someStaticFunction(); } ... } NOT void Foo::something() { ... []() { Foo::someStaticFunction(); } ... } Format the lambda according to the following rules: Always write parentheses for the parameter list, even if the function does not take parameters. []() { doSomething(); } NOT [] { doSomething(); } Place the capture-list, parameter list, return type, and opening brace on the first line, the body indented on the following lines, and the closing brace on a new line. []() -> bool { something(); return isSomethingElse(); } NOT []() -> bool { something(); somethingElse(); } Place a closing parenthesis and semicolon of an enclosing function call on the same line as the closing brace of the lambda. foo([]() { something(); }); If you are using a lambda in an 'if' statement, start the lambda on a new line, to avoid confusion between the opening brace for the lambda and the opening brace for the 'if' statement. if (anyOf(fooList, [](Foo foo) { return foo.isGreat(); }) { return; } NOT if (anyOf(fooList, [](Foo foo) { return foo.isGreat(); }) { return; } Optionally, place the lambda completely on one line if it fits. foo([]() { return true; }); if (foo([]() { return true; })) { ... }","title":"Lambdas"},{"location":"contributing/coding-conventions/cpp-conventions/#auto-keyword","text":"Optionally, you can use the auto keyword in the following cases. If in doubt, for example if using auto could make the code less readable, do not use auto. Keep in mind that code is read much more often than written. When it avoids repetition of a type in the same statement. auto something = new MyCustomType; auto keyEvent = static_cast<QKeyEvent *>(event); auto myList = QStringList() << QLatin1String(\"FooThing\") << QLatin1String(\"BarThing\"); When assigning iterator types. auto it = myList.const_iterator();","title":"auto Keyword"},{"location":"contributing/coding-conventions/cpp-style/","text":"C++ Coding Style This is an overview of the low-level coding conventions we use when writing Qt code. See C++ Coding Conventions for the higher-level conventions. The data has been gathered by mining the Qt sources, discussion forums, email threads and through collaboration of the developers. Indentation 4 spaces are used for indentation Spaces, not tabs! Declaring variables Declare each variable on a separate line Avoid short or meaningless names (e.g. \"a\", \"rbarr\", \"nughdeget\") Single character variable names are only okay for counters and temporaries, where the purpose of the variable is obvious Wait when declaring a variable until it is needed // Wrong int a, b; char *c, *d; // Correct int height; int width; char *nameOfThis; char *nameOfThat; Variables and functions start with a lower-case letter. Each consecutive word in a variable's name starts with an upper-case letter Avoid abbreviations // Wrong short Cntr; char ITEM_DELIM = ' '; // Correct short counter; char itemDelimiter = ' '; Classes always start with an upper-case letter. Public classes start with a 'Q' (QRgb) followed by an upper case letter. Public functions most often start with a 'q' (qRgb). Acronyms are camel-cased (e.g. QXmlStreamReader, not QXMLStreamReader). Whitespace Use blank lines to group statements together where suited Always use only one blank line Always use a single space after a keyword and before a curly brace: // Wrong if(foo){ } // Correct if (foo) { } For pointers or references, always use a single space between the type and ' ' or '&', but no space between the ' ' or '&' and the variable name: char *x; const QString &myString; const char - const y = \"hello\"; Surround binary operators with spaces No space after a cast Avoid C-style casts when possible // Wrong char- blockOfMemory = (char- ) malloc(data.size()); // Correct char *blockOfMemory = reinterpret_cast<char *>(malloc(data.size())); Do not put multiple statements on one line By extension, use a new line for the body of a control flow statement: // Wrong if (foo) bar(); // Correct if (foo) bar(); Braces Use attached braces: The opening brace goes on the same line as the start of the statement. If the closing brace is followed by another keyword, it goes into the same line as well: // Wrong if (codec) { } else { } // Correct if (codec) { } else { } Exception: Function implementations and class declarations always have the left brace on the start of a line: static void foo(int g) { qDebug(\"foo: %i\", g); } class Moo { }; Use curly braces only when the body of a conditional statement contains more than one line: // Wrong if (address.isEmpty()) { return false; } for (int i = 0; i < 10; +''i) { qDebug(\"%i\", i); } // Correct if (address.isEmpty()) return false; for (int i = 0; i < 10;i) qDebug(\"%i\", i); Exception 1: Use braces also if the parent statement covers several lines / wraps: // Correct if (address.isEmpty() || !isValid() || !codec) { return false; } Exception 2: Brace symmetry: Use braces also in if-then-else blocks where either the if-code or the else-code covers several lines: // Wrong if (address.isEmpty()) qDebug(\"empty!\"); else { qDebug(\"%s\", qPrintable(address)); it; } // Correct if (address.isEmpty()) { qDebug(\"empty!\"); } else { qDebug(\"%s\", qPrintable(address)); it; } // Wrong if (a) \u2026 else if (b) \u2026 // Correct if (a) { \u2026 } else { if (b) \u2026 } Use curly braces when the body of a conditional statement is empty // Wrong while (a); // Correct while (a) {} Parentheses Use parentheses to group expressions: // Wrong if (a && b || c) // Correct if ((a && b) || c) // Wrong a + b & c // Correct (a + b) & c Switch statements The case labels are in the same column as the switch Every case must have a break (or return) statement at the end or a comment to indicate that there's intentionally no break, unless another case follows immediately. switch (myEnum) { case Value1: doSomething(); break; case Value2: case Value3: doSomethingElse(); // fall through default: defaultHandling(); break; } Jump statements (break, continue, return, and goto) Do not put 'else' after jump statements: // Wrong if (thisOrThat) return; else somethingElse(); // Correct if (thisOrThat) return; somethingElse(); Exception: If the code is inherently symmetrical, use of 'else' is allowed to visualize that symmetry Line breaks Keep lines shorter than 100 characters; wrap if necessary Comment/apidoc lines should be kept below 80 columns of actual text. Adjust to the surroundings, and try to flow the text in a way that avoids \"jagged\" paragraphs. Commas go at the end of wrapped lines; operators start at the beginning of the new lines. An operator at the end of the line is easy to miss if the editor is too narrow. // Wrong if (longExpression + otherLongExpression + otherOtherLongExpression) { } // Correct if (longExpression + otherLongExpression + otherOtherLongExpression) { } General exception When strictly following a rule makes your code look bad, feel free to break it Artistic Style The following snippet can be used by artistic style for reformatting your code. --style=kr --indent=spaces=4 --align-pointer=name --align-reference=name --convert-tabs --attach-namespaces --max-code-length=100 --max-instatement-indent=120 --pad-header --pad-oper Note that \"unlimited\" --max-instatement-indent is used only because astyle is not smart enough to wrap the first argument if subsequent lines would need indentation limitation. You are encouraged to manually limit in-statement-indent to roughly 50 colums: int foo = some_really_long_function_name(and_another_one_to_drive_the_point_home( first_argument, second_argument, third_arugment));","title":"C++ Coding Style"},{"location":"contributing/coding-conventions/cpp-style/#c-coding-style","text":"This is an overview of the low-level coding conventions we use when writing Qt code. See C++ Coding Conventions for the higher-level conventions. The data has been gathered by mining the Qt sources, discussion forums, email threads and through collaboration of the developers.","title":"C++ Coding Style"},{"location":"contributing/coding-conventions/cpp-style/#indentation","text":"4 spaces are used for indentation Spaces, not tabs!","title":"Indentation"},{"location":"contributing/coding-conventions/cpp-style/#declaring-variables","text":"Declare each variable on a separate line Avoid short or meaningless names (e.g. \"a\", \"rbarr\", \"nughdeget\") Single character variable names are only okay for counters and temporaries, where the purpose of the variable is obvious Wait when declaring a variable until it is needed // Wrong int a, b; char *c, *d; // Correct int height; int width; char *nameOfThis; char *nameOfThat; Variables and functions start with a lower-case letter. Each consecutive word in a variable's name starts with an upper-case letter Avoid abbreviations // Wrong short Cntr; char ITEM_DELIM = ' '; // Correct short counter; char itemDelimiter = ' '; Classes always start with an upper-case letter. Public classes start with a 'Q' (QRgb) followed by an upper case letter. Public functions most often start with a 'q' (qRgb). Acronyms are camel-cased (e.g. QXmlStreamReader, not QXMLStreamReader).","title":"Declaring variables"},{"location":"contributing/coding-conventions/cpp-style/#whitespace","text":"Use blank lines to group statements together where suited Always use only one blank line Always use a single space after a keyword and before a curly brace: // Wrong if(foo){ } // Correct if (foo) { } For pointers or references, always use a single space between the type and ' ' or '&', but no space between the ' ' or '&' and the variable name: char *x; const QString &myString; const char - const y = \"hello\"; Surround binary operators with spaces No space after a cast Avoid C-style casts when possible // Wrong char- blockOfMemory = (char- ) malloc(data.size()); // Correct char *blockOfMemory = reinterpret_cast<char *>(malloc(data.size())); Do not put multiple statements on one line By extension, use a new line for the body of a control flow statement: // Wrong if (foo) bar(); // Correct if (foo) bar();","title":"Whitespace"},{"location":"contributing/coding-conventions/cpp-style/#braces","text":"Use attached braces: The opening brace goes on the same line as the start of the statement. If the closing brace is followed by another keyword, it goes into the same line as well: // Wrong if (codec) { } else { } // Correct if (codec) { } else { } Exception: Function implementations and class declarations always have the left brace on the start of a line: static void foo(int g) { qDebug(\"foo: %i\", g); } class Moo { }; Use curly braces only when the body of a conditional statement contains more than one line: // Wrong if (address.isEmpty()) { return false; } for (int i = 0; i < 10; +''i) { qDebug(\"%i\", i); } // Correct if (address.isEmpty()) return false; for (int i = 0; i < 10;i) qDebug(\"%i\", i); Exception 1: Use braces also if the parent statement covers several lines / wraps: // Correct if (address.isEmpty() || !isValid() || !codec) { return false; } Exception 2: Brace symmetry: Use braces also in if-then-else blocks where either the if-code or the else-code covers several lines: // Wrong if (address.isEmpty()) qDebug(\"empty!\"); else { qDebug(\"%s\", qPrintable(address)); it; } // Correct if (address.isEmpty()) { qDebug(\"empty!\"); } else { qDebug(\"%s\", qPrintable(address)); it; } // Wrong if (a) \u2026 else if (b) \u2026 // Correct if (a) { \u2026 } else { if (b) \u2026 } Use curly braces when the body of a conditional statement is empty // Wrong while (a); // Correct while (a) {}","title":"Braces"},{"location":"contributing/coding-conventions/cpp-style/#parentheses","text":"Use parentheses to group expressions: // Wrong if (a && b || c) // Correct if ((a && b) || c) // Wrong a + b & c // Correct (a + b) & c","title":"Parentheses"},{"location":"contributing/coding-conventions/cpp-style/#switch-statements","text":"The case labels are in the same column as the switch Every case must have a break (or return) statement at the end or a comment to indicate that there's intentionally no break, unless another case follows immediately. switch (myEnum) { case Value1: doSomething(); break; case Value2: case Value3: doSomethingElse(); // fall through default: defaultHandling(); break; }","title":"Switch statements"},{"location":"contributing/coding-conventions/cpp-style/#jump-statements-break-continue-return-and-goto","text":"Do not put 'else' after jump statements: // Wrong if (thisOrThat) return; else somethingElse(); // Correct if (thisOrThat) return; somethingElse(); Exception: If the code is inherently symmetrical, use of 'else' is allowed to visualize that symmetry","title":"Jump statements (break, continue, return, and goto)"},{"location":"contributing/coding-conventions/cpp-style/#line-breaks","text":"Keep lines shorter than 100 characters; wrap if necessary Comment/apidoc lines should be kept below 80 columns of actual text. Adjust to the surroundings, and try to flow the text in a way that avoids \"jagged\" paragraphs. Commas go at the end of wrapped lines; operators start at the beginning of the new lines. An operator at the end of the line is easy to miss if the editor is too narrow. // Wrong if (longExpression + otherLongExpression + otherOtherLongExpression) { } // Correct if (longExpression + otherLongExpression + otherOtherLongExpression) { }","title":"Line breaks"},{"location":"contributing/coding-conventions/cpp-style/#general-exception","text":"When strictly following a rule makes your code look bad, feel free to break it","title":"General exception"},{"location":"contributing/coding-conventions/cpp-style/#artistic-style","text":"The following snippet can be used by artistic style for reformatting your code. --style=kr --indent=spaces=4 --align-pointer=name --align-reference=name --convert-tabs --attach-namespaces --max-code-length=100 --max-instatement-indent=120 --pad-header --pad-oper Note that \"unlimited\" --max-instatement-indent is used only because astyle is not smart enough to wrap the first argument if subsequent lines would need indentation limitation. You are encouraged to manually limit in-statement-indent to roughly 50 colums: int foo = some_really_long_function_name(and_another_one_to_drive_the_point_home( first_argument, second_argument, third_arugment));","title":"Artistic Style"},{"location":"contributing/coding-conventions/design-philosophy/","text":"Design Philosophy What Design Is Not Before getting into the details we need to clarify what design is about. Design is not something you can add later. Design is an integral part of building something. It's not just colors and fonts, design is how things work. When you add a button to your application, that is design. You made a decision to add a button with a particular label, icon, location and size. The decisions you make are designs. Design is not an opinion Design is testable, therefore one design will meet a specific goal better than another one. Design is about solving a specific problem and so you can objectively compare the effectiveness of two designs at solving those problems. Starting with the fundamentals Liri strives to provide a beautiful but unique and user friendly experience to the user. Before you begin designing your application, get fully acquainted with the environment. Understanding the interior of Liri will aid you in producing an application that integrates seamlessly with the desktop environment and is enjoyable to the user. Most individuals are not acquainted with the concepts or principles of human interface design, but they can easily identify which applications follow the guidelines and which applications stray from them. Become familiar with Liri and the fundamental principles contained within the human interface guidelines so that you can integrate them into your design to create the most user-friendly application possible.","title":"Design Philosophy"},{"location":"contributing/coding-conventions/design-philosophy/#design-philosophy","text":"","title":"Design Philosophy"},{"location":"contributing/coding-conventions/design-philosophy/#what-design-is-not","text":"Before getting into the details we need to clarify what design is about. Design is not something you can add later. Design is an integral part of building something. It's not just colors and fonts, design is how things work. When you add a button to your application, that is design. You made a decision to add a button with a particular label, icon, location and size. The decisions you make are designs. Design is not an opinion Design is testable, therefore one design will meet a specific goal better than another one. Design is about solving a specific problem and so you can objectively compare the effectiveness of two designs at solving those problems.","title":"What Design Is Not"},{"location":"contributing/coding-conventions/design-philosophy/#starting-with-the-fundamentals","text":"Liri strives to provide a beautiful but unique and user friendly experience to the user. Before you begin designing your application, get fully acquainted with the environment. Understanding the interior of Liri will aid you in producing an application that integrates seamlessly with the desktop environment and is enjoyable to the user. Most individuals are not acquainted with the concepts or principles of human interface design, but they can easily identify which applications follow the guidelines and which applications stray from them. Become familiar with Liri and the fundamental principles contained within the human interface guidelines so that you can integrate them into your design to create the most user-friendly application possible.","title":"Starting with the fundamentals"},{"location":"contributing/coding-conventions/qml-conventions/","text":"QML Coding Conventions This document contains the QML coding conventions that all Liri projects follow. QML Object Declarations Throughout our code, documentation and examples, QML object attributes are always structured in the following order: id property declarations signal declarations JavaScript functions object properties child objects states transitions For better readability, we separate these different parts with an empty line. For example, a hypothetical photo QML object would look like this: Rectangle { id: photo // id on the first line makes it easy to find an object property bool thumbnail: false // property declarations property alias image: photoImage.source signal clicked() // signal declarations function doSomething(x) // javascript functions { return x + photoImage.width; } color: \"gray\" // object properties x: 20; y: 20; height: 150 // try to group related properties together width: { // large bindings if (photoImage.width > 200) photoImage.width; else 200; } Rectangle { // child objects id: border anchors.centerIn: parent; color: \"white\" Image { id: photoImage; anchors.centerIn: parent } } states: State { // states name: \"selected\" PropertyChanges { target: border; color: \"red\" } } transitions: Transition { // transitions from: \"\"; to: \"selected\" ColorAnimation { target: border; duration: 200 } } } Grouped Properties If using multiple properties from a group of properties, consider using group notation instead of dot notation if it improves readability. For example, this: Rectangle { anchors.left: parent.left; anchors.top: parent.top; anchors.right: parent.right; anchors.leftMargin: 20 } Text { text: \"hello\" font.bold: true; font.italic: true; font.pixelSize: 20; font.capitalization: Font.AllUppercase } could be written like this: Rectangle { anchors { left: parent.left; top: parent.top; right: parent.right; leftMargin: 20 } } Text { text: \"hello\" font { bold: true; italic: true; pixelSize: 20; capitalization: Font.AllUppercase } } Lists If a list contains only one element, we generally omit the square brackets. For example, it is very common for a component to only have one state. In this case, instead of: states: [ State { name: \"open\" PropertyChanges { target: container; width: 200 } } ] we will write this: states: State { name: \"open\" PropertyChanges { target: container; width: 200 } } JavaScript Code If the script is a single expression, we recommend writing it inline: Rectangle { color: \"blue\"; width: parent.width / 3 } If the script is only a couple of lines long, we generally use a block: Rectangle { color: \"blue\" width: { var w = parent.width / 3; console.debug(w); return w; } } If the script is more than a couple of lines long or can be used by different objects, we recommend creating a function and calling it like this: function calculateWidth(object) { var w = object.width / 3; // ... // more javascript code // ... console.debug(w); return w; } Rectangle { color: \"blue\"; width: calculateWidth(parent) } For long scripts, we will put the functions in their own JavaScript file and import it like this: import \"myscript.js\" as Script Rectangle { color: \"blue\"; width: Script.calculateWidth(parent) } If the code is longer than one line and hence within a block, we use semicolons to indicate the end of each statement: MouseArea { anchors.fill: parent onClicked: { var scenePos = mapToItem(null, mouseX, mouseY); console.log(\"MouseArea was clicked at scene pos \" + scenePos); } } This document is based on Qt's QML Coding Conventions which is (C) 2017 The Qt Company Ltd, licensed under the terms of the GNU Free Documentation License version 1.3 as published by the Free Software Foundation.","title":"QML Coding Conventions"},{"location":"contributing/coding-conventions/qml-conventions/#qml-coding-conventions","text":"This document contains the QML coding conventions that all Liri projects follow.","title":"QML Coding Conventions"},{"location":"contributing/coding-conventions/qml-conventions/#qml-object-declarations","text":"Throughout our code, documentation and examples, QML object attributes are always structured in the following order: id property declarations signal declarations JavaScript functions object properties child objects states transitions For better readability, we separate these different parts with an empty line. For example, a hypothetical photo QML object would look like this: Rectangle { id: photo // id on the first line makes it easy to find an object property bool thumbnail: false // property declarations property alias image: photoImage.source signal clicked() // signal declarations function doSomething(x) // javascript functions { return x + photoImage.width; } color: \"gray\" // object properties x: 20; y: 20; height: 150 // try to group related properties together width: { // large bindings if (photoImage.width > 200) photoImage.width; else 200; } Rectangle { // child objects id: border anchors.centerIn: parent; color: \"white\" Image { id: photoImage; anchors.centerIn: parent } } states: State { // states name: \"selected\" PropertyChanges { target: border; color: \"red\" } } transitions: Transition { // transitions from: \"\"; to: \"selected\" ColorAnimation { target: border; duration: 200 } } }","title":"QML Object Declarations"},{"location":"contributing/coding-conventions/qml-conventions/#grouped-properties","text":"If using multiple properties from a group of properties, consider using group notation instead of dot notation if it improves readability. For example, this: Rectangle { anchors.left: parent.left; anchors.top: parent.top; anchors.right: parent.right; anchors.leftMargin: 20 } Text { text: \"hello\" font.bold: true; font.italic: true; font.pixelSize: 20; font.capitalization: Font.AllUppercase } could be written like this: Rectangle { anchors { left: parent.left; top: parent.top; right: parent.right; leftMargin: 20 } } Text { text: \"hello\" font { bold: true; italic: true; pixelSize: 20; capitalization: Font.AllUppercase } }","title":"Grouped Properties"},{"location":"contributing/coding-conventions/qml-conventions/#lists","text":"If a list contains only one element, we generally omit the square brackets. For example, it is very common for a component to only have one state. In this case, instead of: states: [ State { name: \"open\" PropertyChanges { target: container; width: 200 } } ] we will write this: states: State { name: \"open\" PropertyChanges { target: container; width: 200 } }","title":"Lists"},{"location":"contributing/coding-conventions/qml-conventions/#javascript-code","text":"If the script is a single expression, we recommend writing it inline: Rectangle { color: \"blue\"; width: parent.width / 3 } If the script is only a couple of lines long, we generally use a block: Rectangle { color: \"blue\" width: { var w = parent.width / 3; console.debug(w); return w; } } If the script is more than a couple of lines long or can be used by different objects, we recommend creating a function and calling it like this: function calculateWidth(object) { var w = object.width / 3; // ... // more javascript code // ... console.debug(w); return w; } Rectangle { color: \"blue\"; width: calculateWidth(parent) } For long scripts, we will put the functions in their own JavaScript file and import it like this: import \"myscript.js\" as Script Rectangle { color: \"blue\"; width: Script.calculateWidth(parent) } If the code is longer than one line and hence within a block, we use semicolons to indicate the end of each statement: MouseArea { anchors.fill: parent onClicked: { var scenePos = mapToItem(null, mouseX, mouseY); console.log(\"MouseArea was clicked at scene pos \" + scenePos); } } This document is based on Qt's QML Coding Conventions which is (C) 2017 The Qt Company Ltd, licensed under the terms of the GNU Free Documentation License version 1.3 as published by the Free Software Foundation.","title":"JavaScript Code"},{"location":"contributing/contributor-guide/","text":"With Google's repo command you can download all the projects at once and open them from QtCreator. Prerequisites In this guide we assume that you are using the bash shell and QtCreator 4.3.0 or greater. Download sources and prepare for the development Install repo Your Linux distribution might have repo available, check in their repositories. We know Arch Linux has got the package, if you are using it just: sudo pacman -S repo If you are using another distribution and it doesn't have a package available, follow these instructions: Create ~/bin/ subdirectory, include it in PATH, and then switch to it by executing the following commands: mkdir ~/bin/ PATH=~/bin:$PATH Download the repo script by executing the following command: curl http://commondatastorage.googleapis.com/git-repo-downloads/repo > ~/bin/repo Change the attribute of repo to make it executable by executing the command: chmod a+x ~/bin/repo Clone the repositories To clone the latest source of all projects over SSH, perform the following procedure: Firstly, create a new directory for Liri. This will be referred to as repo root in the docs. Switch to it by executing the following commands: mkdir -p ~/git/liri/lirios cd ~/git/liri/lirios Initialize the repository by executing one of the following commands, as appropriate. For write access : repo init -u ssh://git@github.com/lirios/lirios.git -b develop For read-only access: repo init -u https://github.com/lirios/lirios.git -b develop Synchronize the repository by executing the following command: repo sync Get ready for development repo doesn't create local branches for you, hence you end up with a detached head that points to the last known good commit. Before you start developing make sure you have local branches: repo forall -c 'git checkout $REPO_RREV; git submodule update --init --recursive' Now set git to use the commit template that will help you write good commit messages: ROOTDIR=$(pwd) repo forall -c 'git config commit.template $ROOTDIR/.commit-template' Setup the environment The installation root is the directory where all files will be installed when building the Liri master project from QtCreator. To set your environment variables correctly so you will be able to launch the cross platform apps, run source env-setup.sh [nvidia] Note for users running the Nvidia proprietary drivers: Supply the nvidia argument every time you run the env-setup.sh script By default, .build/install-root inside your repo root will be used as installation root. To change this, issue the command with the LIRIDIR prefix instead LIRIDIR=\"path/to/directory\" source env-setup.sh [nvidia] Open the project Run QtCreator and open the master project file CMakeLists.txt inside your repo root. Click on the \"Projects\" button and setup the build, this needs to be done only the first time. Set the build directory to whatever you want, just make sure you have access to the directory: Make sure the build steps are configured like in this screenshot: Set CMAKE_INSTALL_PREFIX to change the installation root. Remember to replace /home/plfiorini to your actual home directory. If you don't want to run all the unit tests during the build set BUILD_TESTING to OFF . Now create a custom build step like this: The custom build step will compile the settings schemas so it must be there. Update sources New repositories might be added to the manifest or new commits are pushed to existing repositories, so from time to time you need to fetch updated versions. Make sure all your changes are either committed or stashed and run: cd ~/git/liri/lirios repo sync Now set git to use the commit template that will help you write good commit messages: ROOTDIR=$(pwd) repo forall -c 'git config commit.template $ROOTDIR/.commit-template'","title":"Contributor Guide"},{"location":"contributing/contributor-guide/#prerequisites","text":"In this guide we assume that you are using the bash shell and QtCreator 4.3.0 or greater.","title":"Prerequisites"},{"location":"contributing/contributor-guide/#download-sources-and-prepare-for-the-development","text":"","title":"Download sources and prepare for the development"},{"location":"contributing/contributor-guide/#install-repo","text":"Your Linux distribution might have repo available, check in their repositories. We know Arch Linux has got the package, if you are using it just: sudo pacman -S repo If you are using another distribution and it doesn't have a package available, follow these instructions: Create ~/bin/ subdirectory, include it in PATH, and then switch to it by executing the following commands: mkdir ~/bin/ PATH=~/bin:$PATH Download the repo script by executing the following command: curl http://commondatastorage.googleapis.com/git-repo-downloads/repo > ~/bin/repo Change the attribute of repo to make it executable by executing the command: chmod a+x ~/bin/repo","title":"Install repo"},{"location":"contributing/contributor-guide/#clone-the-repositories","text":"To clone the latest source of all projects over SSH, perform the following procedure: Firstly, create a new directory for Liri. This will be referred to as repo root in the docs. Switch to it by executing the following commands: mkdir -p ~/git/liri/lirios cd ~/git/liri/lirios Initialize the repository by executing one of the following commands, as appropriate. For write access : repo init -u ssh://git@github.com/lirios/lirios.git -b develop For read-only access: repo init -u https://github.com/lirios/lirios.git -b develop Synchronize the repository by executing the following command: repo sync","title":"Clone the repositories"},{"location":"contributing/contributor-guide/#get-ready-for-development","text":"repo doesn't create local branches for you, hence you end up with a detached head that points to the last known good commit. Before you start developing make sure you have local branches: repo forall -c 'git checkout $REPO_RREV; git submodule update --init --recursive' Now set git to use the commit template that will help you write good commit messages: ROOTDIR=$(pwd) repo forall -c 'git config commit.template $ROOTDIR/.commit-template'","title":"Get ready for development"},{"location":"contributing/contributor-guide/#setup-the-environment","text":"The installation root is the directory where all files will be installed when building the Liri master project from QtCreator. To set your environment variables correctly so you will be able to launch the cross platform apps, run source env-setup.sh [nvidia] Note for users running the Nvidia proprietary drivers: Supply the nvidia argument every time you run the env-setup.sh script By default, .build/install-root inside your repo root will be used as installation root. To change this, issue the command with the LIRIDIR prefix instead LIRIDIR=\"path/to/directory\" source env-setup.sh [nvidia]","title":"Setup the environment"},{"location":"contributing/contributor-guide/#open-the-project","text":"Run QtCreator and open the master project file CMakeLists.txt inside your repo root. Click on the \"Projects\" button and setup the build, this needs to be done only the first time. Set the build directory to whatever you want, just make sure you have access to the directory: Make sure the build steps are configured like in this screenshot: Set CMAKE_INSTALL_PREFIX to change the installation root. Remember to replace /home/plfiorini to your actual home directory. If you don't want to run all the unit tests during the build set BUILD_TESTING to OFF . Now create a custom build step like this: The custom build step will compile the settings schemas so it must be there.","title":"Open the project"},{"location":"contributing/contributor-guide/#update-sources","text":"New repositories might be added to the manifest or new commits are pushed to existing repositories, so from time to time you need to fetch updated versions. Make sure all your changes are either committed or stashed and run: cd ~/git/liri/lirios repo sync Now set git to use the commit template that will help you write good commit messages: ROOTDIR=$(pwd) repo forall -c 'git config commit.template $ROOTDIR/.commit-template'","title":"Update sources"},{"location":"modules/","text":"Modules All modules revolve around Fluid , a library that implements the Material Design guidelines with QtQuick. You can learn more about here . To summarize the area of interest we have: Cross-platform apps Core apps Libraries Desktop environment Operating system Cross-platform apps Cross-platform apps are designed to run on all operating systems such as Linux, macOS, Windows and mobile platforms like Android and iOS. The cross-platform apps are: Browser (Docs here ) Calculator Text (Docs here ) Core apps Core apps are primarily designed with Linux in mind and, in some cases, might even be useful only on LiriOS. The core apps are: AppCenter Files Terminal Libraries We also develop the following libraries: Fluid QtAccountsService QtGSettings QtUDev CMakeShared LibLiri Desktop environment The desktop environment is comprised of the following projects, all with the same release cycle. Shell Screen Cast Screenshot Settings eglfs Material Decoration QPA Theme PulseAudio Support NetworkManager Support Power Manager Portal Implementation XWayland Support Themes Operating system Calamares Branding","title":"Overview"},{"location":"modules/#modules","text":"All modules revolve around Fluid , a library that implements the Material Design guidelines with QtQuick. You can learn more about here . To summarize the area of interest we have: Cross-platform apps Core apps Libraries Desktop environment Operating system","title":"Modules"},{"location":"modules/#cross-platform-apps","text":"Cross-platform apps are designed to run on all operating systems such as Linux, macOS, Windows and mobile platforms like Android and iOS. The cross-platform apps are: Browser (Docs here ) Calculator Text (Docs here )","title":"Cross-platform apps"},{"location":"modules/#core-apps","text":"Core apps are primarily designed with Linux in mind and, in some cases, might even be useful only on LiriOS. The core apps are: AppCenter Files Terminal","title":"Core apps"},{"location":"modules/#libraries","text":"We also develop the following libraries: Fluid QtAccountsService QtGSettings QtUDev CMakeShared LibLiri","title":"Libraries"},{"location":"modules/#desktop-environment","text":"The desktop environment is comprised of the following projects, all with the same release cycle. Shell Screen Cast Screenshot Settings eglfs Material Decoration QPA Theme PulseAudio Support NetworkManager Support Power Manager Portal Implementation XWayland Support Themes","title":"Desktop environment"},{"location":"modules/#operating-system","text":"Calamares Branding","title":"Operating system"},{"location":"modules/browser/","text":"Browser Shortcuts","title":"Overview"},{"location":"modules/browser/#browser","text":"Shortcuts","title":"Browser"},{"location":"modules/browser/shortcuts/","text":"Shortcuts Liri Browser is using Qt's magic to offer platform independent keyboard shortcuts. However, this is a list of shortcuts which should work on all platforms: Action Shortcut New tab Ctrl+T Close tab Ctrl+W Focus tab Alt+[0...9] Back Alt+Left Forward Alt+Right Focus url Ctrl+L Refresh F5 Stop Esc","title":"Shortcuts"},{"location":"modules/browser/shortcuts/#shortcuts","text":"Liri Browser is using Qt's magic to offer platform independent keyboard shortcuts. However, this is a list of shortcuts which should work on all platforms: Action Shortcut New tab Ctrl+T Close tab Ctrl+W Focus tab Alt+[0...9] Back Alt+Left Forward Alt+Right Focus url Ctrl+L Refresh F5 Stop Esc","title":"Shortcuts"},{"location":"modules/text/","text":"Text Syntax Highlighting","title":"Overview"},{"location":"modules/text/#text","text":"Syntax Highlighting","title":"Text"},{"location":"modules/text/syntax-highlighting/","text":"Syntax Highlighting This page describes Liri Text's syntax highlighting system. Please familiarize yourself with it's content before reporting bugs against syntax highlighting or making contributions to it's development. Liri Text implements GtkSourceView specification for language definitions with only exception: dupnames attribute is not currently supported . If you find any other difference in highlighting behavior of GtkSourceView/gedit and Liri Text, please report it as a bug. Manually adding language definitions You can manually add languages to your local installation of Liri Text. To do so, put language definition into one of the following directories. System directory INSTALL_PREFIX/share/liri-text/language-specs/ on Linux, where INSTALL_PREFIX is defined during build time and usually equals to /usr for system packages or /usr/local for manual builds. BUNDLE_PATH/Resources/language-specs/ on macOS. APP_DIRECTORY\\language-specs\\ on Windows. User directory USER_DATA/Liri/Text/language-specs/ where USER_DATA is OS-dependant. Contributing additional languages to Liri Text We will gladly accept more languages into the base package. If you want to contribute one, please try to follow advices and conventions from GtkSourceView stated here . Once you have a language definition you're ready to send to us, add it to data/language-specs directory of this repository and open a pull request. Reporting bugs If you find a misbehavior in Liri Text's syntax highlighting, please check if it differs from the one of gedit before opening an issue. All prebundled languages should behave identically, third-party languages too as long as they don't have dupnames attribute set for any context or regex. If the behavior is identical, but you think it's incorrect, you can still open an issue and we'll consider changing corresponding language definition.","title":"Syntax Highlighting"},{"location":"modules/text/syntax-highlighting/#syntax-highlighting","text":"This page describes Liri Text's syntax highlighting system. Please familiarize yourself with it's content before reporting bugs against syntax highlighting or making contributions to it's development. Liri Text implements GtkSourceView specification for language definitions with only exception: dupnames attribute is not currently supported . If you find any other difference in highlighting behavior of GtkSourceView/gedit and Liri Text, please report it as a bug.","title":"Syntax Highlighting"},{"location":"modules/text/syntax-highlighting/#manually-adding-language-definitions","text":"You can manually add languages to your local installation of Liri Text. To do so, put language definition into one of the following directories.","title":"Manually adding language definitions"},{"location":"modules/text/syntax-highlighting/#system-directory","text":"INSTALL_PREFIX/share/liri-text/language-specs/ on Linux, where INSTALL_PREFIX is defined during build time and usually equals to /usr for system packages or /usr/local for manual builds. BUNDLE_PATH/Resources/language-specs/ on macOS. APP_DIRECTORY\\language-specs\\ on Windows.","title":"System directory"},{"location":"modules/text/syntax-highlighting/#user-directory","text":"USER_DATA/Liri/Text/language-specs/ where USER_DATA is OS-dependant.","title":"User directory"},{"location":"modules/text/syntax-highlighting/#contributing-additional-languages-to-liri-text","text":"We will gladly accept more languages into the base package. If you want to contribute one, please try to follow advices and conventions from GtkSourceView stated here . Once you have a language definition you're ready to send to us, add it to data/language-specs directory of this repository and open a pull request.","title":"Contributing additional languages to Liri Text"},{"location":"modules/text/syntax-highlighting/#reporting-bugs","text":"If you find a misbehavior in Liri Text's syntax highlighting, please check if it differs from the one of gedit before opening an issue. All prebundled languages should behave identically, third-party languages too as long as they don't have dupnames attribute set for any context or regex. If the behavior is identical, but you think it's incorrect, you can still open an issue and we'll consider changing corresponding language definition.","title":"Reporting bugs"},{"location":"packaging/","text":"Packaging We aim to provide a sensible set of packages for our modules upstream. Cross-distribution Bundles Currently, we provide the following cross-distribution bundles: Flatpak Snap AppImage Distribution Packages Packages for: Arch Linux Windows & macOS We also aim to provide binaries of our cross-platform apps for Windows and macOS.","title":"Overview"},{"location":"packaging/#packaging","text":"We aim to provide a sensible set of packages for our modules upstream.","title":"Packaging"},{"location":"packaging/#cross-distribution-bundles","text":"Currently, we provide the following cross-distribution bundles: Flatpak Snap AppImage","title":"Cross-distribution Bundles"},{"location":"packaging/#distribution-packages","text":"Packages for: Arch Linux","title":"Distribution Packages"},{"location":"packaging/#windows-macos","text":"We also aim to provide binaries of our cross-platform apps for Windows and macOS.","title":"Windows &amp; macOS"},{"location":"packaging/snap/","text":"Snap Our snap packages are built with snapcraft . If you are new to snapcraft, we highly recommend you to check out their introduction to building snaps There are a few repositories containing sources and packaging data relevant for building our snap packages. Platform snap Our platform snap serves as a bundle for libraries commonly used by our projects. It contains Qt, KDE dependencies, Fluid and some other pieces. Right now it has to be build on Ubuntu 16.04 because this is the current base for snap applications. Even if you are running Ubuntu 16.04 however, you should use snapcraft cleanbuild or create your own LXC container to build the platform snap in. By doing so, you make sure you don't pollute your system with libraries installed for the snap and you also make sure the snap will not be polluted by your system. Be warned that it will download and build a big chunk of its contents from source so the build might (depending on your machine) take several hours and will use multiple gigabytes of hard disk space. Naming and versioning Projects depending on the platform snap connect to it using the content interface. Unfortunately, the only way to handle compatibility breaks right now is to publish a new platform snap with a new name. Because of the way snap is designed, there is currently no way to have more than one version of a snap package installed. Therefore there is no way for a snap to pin a given version of another snap (like the platform snap) as that would require the ability to have mutliple versions installed. The platform snap naming roughly follows the Liri OS versioning and looks like the following: For a Liri OS version following semver <major>.<minor>.<patch> , the platform snap naming equals liri-platform-<major>-<minor>[-<release build>] . <release build> is an incremental number to handle incompatible changes between Liri OS releases. For example, consider the following scenario: Liri OS 1.0.0 gets released. liri-platform-1-0 gets released. An incompatible change in one of the included packages happens which would affect projects depending on the platform snap. As Liri OS 1.1.0 is not released yet, liri-platform-1-0-1 is being created. Once Liri OS 1.1.0 is out, liri-platform-1-1 will be created. Snapcraft parts To deduplicate snapcraft configuration, there is a set of snapcraft parts available. They can be used in snap applications using the after keywoard, e.g. after: [liri-platform-<version>] , where <version> is the current platform snap version. Snapcraft parts contain a launcher to manage the connection with the platform snap and setup the runtime environment as well as other assets like a qt.conf and workarounds for upstream issues. See the readme in the GitHub repository for more information. Snapcraft plugins Snapcraft plugins are used to share a common set of custom snapcraft plugins that are used by the projects depending on the platform snap. The custom Qbs plugin for example sets up the build environment to make it possible to build packages against the platform snap package. Snap packages The snap packages repository is where development on the snap packages for our projects takes place. The packaging depends on the snapcraft plugins and parts mentioned above as well as the platform snap at build time.","title":"Snap"},{"location":"packaging/snap/#snap","text":"Our snap packages are built with snapcraft . If you are new to snapcraft, we highly recommend you to check out their introduction to building snaps There are a few repositories containing sources and packaging data relevant for building our snap packages.","title":"Snap"},{"location":"packaging/snap/#platform-snap","text":"Our platform snap serves as a bundle for libraries commonly used by our projects. It contains Qt, KDE dependencies, Fluid and some other pieces. Right now it has to be build on Ubuntu 16.04 because this is the current base for snap applications. Even if you are running Ubuntu 16.04 however, you should use snapcraft cleanbuild or create your own LXC container to build the platform snap in. By doing so, you make sure you don't pollute your system with libraries installed for the snap and you also make sure the snap will not be polluted by your system. Be warned that it will download and build a big chunk of its contents from source so the build might (depending on your machine) take several hours and will use multiple gigabytes of hard disk space.","title":"Platform snap"},{"location":"packaging/snap/#naming-and-versioning","text":"Projects depending on the platform snap connect to it using the content interface. Unfortunately, the only way to handle compatibility breaks right now is to publish a new platform snap with a new name. Because of the way snap is designed, there is currently no way to have more than one version of a snap package installed. Therefore there is no way for a snap to pin a given version of another snap (like the platform snap) as that would require the ability to have mutliple versions installed. The platform snap naming roughly follows the Liri OS versioning and looks like the following: For a Liri OS version following semver <major>.<minor>.<patch> , the platform snap naming equals liri-platform-<major>-<minor>[-<release build>] . <release build> is an incremental number to handle incompatible changes between Liri OS releases. For example, consider the following scenario: Liri OS 1.0.0 gets released. liri-platform-1-0 gets released. An incompatible change in one of the included packages happens which would affect projects depending on the platform snap. As Liri OS 1.1.0 is not released yet, liri-platform-1-0-1 is being created. Once Liri OS 1.1.0 is out, liri-platform-1-1 will be created.","title":"Naming and versioning"},{"location":"packaging/snap/#snapcraft-parts","text":"To deduplicate snapcraft configuration, there is a set of snapcraft parts available. They can be used in snap applications using the after keywoard, e.g. after: [liri-platform-<version>] , where <version> is the current platform snap version. Snapcraft parts contain a launcher to manage the connection with the platform snap and setup the runtime environment as well as other assets like a qt.conf and workarounds for upstream issues. See the readme in the GitHub repository for more information.","title":"Snapcraft parts"},{"location":"packaging/snap/#snapcraft-plugins","text":"Snapcraft plugins are used to share a common set of custom snapcraft plugins that are used by the projects depending on the platform snap. The custom Qbs plugin for example sets up the build environment to make it possible to build packages against the platform snap package.","title":"Snapcraft plugins"},{"location":"packaging/snap/#snap-packages","text":"The snap packages repository is where development on the snap packages for our projects takes place. The packaging depends on the snapcraft plugins and parts mentioned above as well as the platform snap at build time.","title":"Snap packages"}]}